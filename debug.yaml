---
# Source: loco/templates/rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: loco-loco-backend
  namespace: default
  labels:
    app.kubernetes.io/component: backend
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-backend
---
# Source: loco/templates/configmap-emulator-scripts.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: loco-loco-emulator-scripts
  namespace: default
  labels:
    app.kubernetes.io/component: emulator
    app.kubernetes.io/part-of: lego-loco-cluster
data:
  health-monitor.sh: |
    #!/usr/bin/env python3
    import http.server
    import socketserver
    import json
    import subprocess
    import time
    import os
    import sys
    
    PORT = 8080
    
    def run_cmd(cmd):
        try:
            return subprocess.check_output(cmd, shell=True, stderr=subprocess.DEVNULL).decode('utf-8').strip()
        except:
            return ""
    
    def get_qemu_health():
        pid = run_cmd("pgrep qemu-system-i386")
        return "true" if pid else "false"
    
    def get_video_health():
        vnc_port = 5901
        vnc_available = "false"
        if run_cmd(f"netstat -ln | grep :{vnc_port}"):
            vnc_available = "true"
        
        display_active = "false"
        frame_rate = 0
        vnc_display = os.environ.get("VNC_DISPLAY", ":1")
        
        # Check X display
        if run_cmd(f"xdpyinfo -display {vnc_display}"):
            display_active = "true"
            # Estimate frame rate
            x_activity = run_cmd(f"xwininfo -display {vnc_display} -root -stats | grep -c 'window'")
            if x_activity and int(x_activity) > 0:
                frame_rate = 15
    
        return {
            "vnc_available": vnc_available == "true",
            "display_active": display_active == "true",
            "estimated_frame_rate": frame_rate,
            "vnc_port": vnc_port,
            "display": vnc_display
        }
    
    def get_audio_health():
        pulse_running = "false"
        if run_cmd("pgrep pulseaudio"):
            pulse_running = "true"
        
        audio_devices = 0
        try:
            out = run_cmd("pactl list short sinks | wc -l")
            audio_devices = int(out) if out else 0
        except:
            pass
    
        alsa_devices = 0
        try:
            out = run_cmd("aplay -l | grep -c 'card '")
            alsa_devices = int(out) if out else 0
        except:
            pass
    
        return {
            "pulse_running": pulse_running == "true",
            "audio_devices": audio_devices,
            "alsa_devices": alsa_devices,
            "estimated_level": 0.5 if audio_devices > 0 else 0,
            "audio_backend": os.environ.get("AUDIO_DEVICE", "pulse")
        }
    
    def get_system_performance():
        # cpu usage from top (simplified)
        cpu_usage = 0
        try:
            # top -bn1 | grep "Cpu(s)" | awk '{print $2}'
            out = run_cmd("top -bn1 | grep 'Cpu(s)' | awk '{print $2}' | cut -d'%' -f1")
            cpu_usage = float(out) if out else 0
        except:
            pass
    
        memory_usage = 0
        try:
            # free | grep Mem | awk '{printf "%.1f", $3/$2 * 100.0}'
            out = run_cmd("free | grep Mem | awk '{printf \"%.1f\", $3/$2 * 100.0}'")
            memory_usage = float(out) if out else 0
        except:
            pass
    
        load_average = 0
        try:
            out = run_cmd("uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | tr -d ','")
            load_average = float(out) if out else 0
        except:
            pass
    
        qemu_pid = run_cmd("pgrep qemu-system-i386")
        qemu_cpu = 0
        qemu_memory = 0
        if qemu_pid:
            try:
                qemu_cpu = float(run_cmd(f"ps -p {qemu_pid} -o %cpu --no-headers") or 0)
                qemu_memory = float(run_cmd(f"ps -p {qemu_pid} -o %mem --no-headers") or 0)
            except:
                pass
    
        return {
            "cpu_usage": cpu_usage,
            "memory_usage": memory_usage,
            "load_average": load_average,
            "qemu_cpu": qemu_cpu,
            "qemu_memory": qemu_memory,
            "qemu_pid": qemu_pid
        }
    
    def get_network_health():
        bridge_up = bool(run_cmd("ip link show loco-br"))
        tap_up = bool(run_cmd("ip link show tap0"))
        
        def read_stat(path):
            try:
                with open(path, 'r') as f:
                    return int(f.read().strip())
            except:
                return 0
    
        return {
            "bridge_up": bridge_up,
            "tap_up": tap_up,
            "tx_packets": read_stat("/sys/class/net/tap0/statistics/tx_packets"),
            "rx_packets": read_stat("/sys/class/net/tap0/statistics/rx_packets"),
            "tx_errors": read_stat("/sys/class/net/tap0/statistics/tx_errors"),
            "rx_errors": read_stat("/sys/class/net/tap0/statistics/rx_errors")
        }
    
    class HealthHandler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            qemu_healthy = get_qemu_health()
            video_health = get_video_health()
            audio_health = get_audio_health()
            
            overall_status = "healthy"
            if qemu_healthy == "false":
                overall_status = "unhealthy"
            elif not video_health["vnc_available"]:
                overall_status = "degraded"
            elif not audio_health["pulse_running"]:
                overall_status = "degraded"
    
            report = {
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                "overall_status": overall_status,
                "qemu_healthy": qemu_healthy == "true",
                "video": video_health,
                "audio": audio_health,
                "performance": get_system_performance(),
                "network": get_network_health()
            }
            
            response_bytes = json.dumps(report).encode('utf-8')
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Content-Length', str(len(response_bytes)))
            self.end_headers()
            self.wfile.write(response_bytes)
    
        def log_message(self, format, *args):
            pass
    
    if __name__ == "__main__":
        print(f"Starting Python health server on port {PORT}")
        # Allow reuse address to avoid "Address already in use" on restart
        socketserver.TCPServer.allow_reuse_address = True
        with socketserver.TCPServer(("", PORT), HealthHandler) as httpd:
            httpd.serve_forever()
---
# Source: loco/templates/configmap-instances.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: loco-loco-instances
  namespace: default
  labels:
    app.kubernetes.io/component: config
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-config
data:
  instances.json: |
    [
      { "id": "instance-0", "streamUrl": "http://loco-loco-emulator-0:5901" }
    ]
---
# Source: loco/templates/configmap-status.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: loco-loco-status
  namespace: default
  labels:
    app.kubernetes.io/component: config
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-config
data:
  status.json: |
    {
      "instance-0": "booting"
    }
---
# Source: loco/templates/storage-strategy.yaml
# Option 1: HostPath Direct Mounts
apiVersion: v1
kind: ConfigMap
metadata:
  name: loco-loco-storage-init
  namespace: default
  labels:
    app.kubernetes.io/component: config
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-storage-config
data:
  init-storage.sh: |
    #!/bin/sh
    set -e
    
    # Create shared directory with proper permissions
    mkdir -p /tmp/loco-art-shared
    chmod 777 /tmp/loco-art-shared
    
    # Create art subdirectory
    mkdir -p /tmp/loco-art-shared/art
    chmod 777 /tmp/loco-art-shared/art
    
    echo "HostPath storage initialized successfully"
    echo "Path: /tmp/loco-art-shared"
    ls -la /tmp/loco-art-shared
---
# Source: loco/templates/persistent-volume.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: win98-disk-pv
  namespace: default
  labels:
    app.kubernetes.io/component: storage
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-storage
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: standard
  hostPath:
    path: /tmp/win98-disk
    type: DirectoryOrCreate
---
# Source: loco/templates/persistent-volume-claim.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: win98-disk
  namespace: default
  labels:
    app.kubernetes.io/component: storage
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-storage
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: standard
  resources:
    requests:
      storage: 10Gi
  volumeName: win98-disk-pv
---
# Source: loco/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: loco-loco-backend-cluster
  labels:
    app.kubernetes.io/component: backend
    app.kubernetes.io/part-of: lego-loco-cluster
rules:
- apiGroups: [""]
  resources: ["namespaces"]
  verbs: ["get", "list", "watch"]
---
# Source: loco/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: loco-loco-backend-cluster
  labels:
    app.kubernetes.io/component: backend
    app.kubernetes.io/part-of: lego-loco-cluster
subjects:
- kind: ServiceAccount
  name: loco-loco-backend
  namespace: default
roleRef:
  kind: ClusterRole
  name: loco-loco-backend-cluster
  apiGroup: rbac.authorization.k8s.io
---
# Source: loco/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: loco-loco-backend
  labels:
    app.kubernetes.io/component: backend
    app.kubernetes.io/part-of: lego-loco-cluster
rules:
- apiGroups: [""]
  resources: ["pods", "services", "endpoints"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["statefulsets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["discovery.k8s.io"]
  resources: ["endpointslices"]
  verbs: ["get", "list", "watch"]
---
# Source: loco/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: loco-loco-backend
  namespace: default
  labels:
    app.kubernetes.io/component: backend
    app.kubernetes.io/part-of: lego-loco-cluster
subjects:
- kind: ServiceAccount
  name: loco-loco-backend
  namespace: default
roleRef:
  kind: Role
  name: loco-loco-backend
  apiGroup: rbac.authorization.k8s.io
---
# Source: loco/templates/backend-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: loco-loco-backend
  namespace: default
  labels:
    app.kubernetes.io/component: backend
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-backend
spec:
  type: NodePort
  selector:
    app: loco-loco-backend
    app.kubernetes.io/component: backend
    app.kubernetes.io/part-of: lego-loco-cluster
  ports:
  - name: http
    port: 3001
    targetPort: 3001
---
# Source: loco/templates/emulator-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: loco-loco-emulator
  namespace: default
  labels:
    app.kubernetes.io/component: emulator
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-emulator
spec:
  clusterIP: None
  publishNotReadyAddresses: true  # Include not-ready pods to show "booting" status
  selector:
    app: loco-loco-emulator
    app.kubernetes.io/component: emulator
    app.kubernetes.io/part-of: lego-loco-cluster
  ports:
  - name: vnc
    port: 5901
    targetPort: 5901
  - name: health
    port: 8080
    targetPort: 8080
---
# Source: loco/templates/frontend-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: loco-loco-frontend
  namespace: default
  labels:
    app.kubernetes.io/component: frontend
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-frontend
spec:
  type: NodePort
  selector:
    app: loco-loco-frontend
    app.kubernetes.io/component: frontend
    app.kubernetes.io/part-of: lego-loco-cluster
  ports:
  - name: http
    port: 3000
    targetPort: 3000
---
# Source: loco/templates/vr-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: loco-loco-vr
  namespace: default
  labels:
    app.kubernetes.io/component: vr
    app.kubernetes.io/part-of: lego-loco-cluster
    app.kubernetes.io/name: lego-loco-vr
spec:
  selector:
    app: loco-loco-vr
    app.kubernetes.io/component: vr
    app.kubernetes.io/part-of: lego-loco-cluster
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
---
# Source: loco/templates/backend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: loco-loco-backend
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: loco-loco-backend
      app.kubernetes.io/component: backend
      app.kubernetes.io/part-of: lego-loco-cluster
  template:
    metadata:
      labels:
        app: loco-loco-backend
        app.kubernetes.io/component: backend
        app.kubernetes.io/part-of: lego-loco-cluster
        app.kubernetes.io/name: lego-loco-backend
    spec:
      serviceAccountName: loco-loco-backend
      containers:
      - name: backend
        image: lego-loco-backend:dns-fix-v1
        imagePullPolicy: Never
        env:
        - name: KUBERNETES_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        ports:
        - containerPort: 3001
        resources:
          limits:
            cpu: 500m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 256Mi
        startupProbe:
          httpGet:
            path: /health
            port: 3001
          failureThreshold: 18
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: instances-config
          mountPath: /app/config/instances.json
          subPath: instances.json
        - name: status-config
          mountPath: /app/config/status.json
          subPath: status.json
      volumes:
      - name: instances-config
        configMap:
          name: loco-loco-instances
      - name: status-config
        configMap:
          name: loco-loco-status
---
# Source: loco/templates/frontend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: loco-loco-frontend
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: loco-loco-frontend
      app.kubernetes.io/component: frontend
      app.kubernetes.io/part-of: lego-loco-cluster
  template:
    metadata:
      labels:
        app: loco-loco-frontend
        app.kubernetes.io/component: frontend
        app.kubernetes.io/part-of: lego-loco-cluster
        app.kubernetes.io/name: lego-loco-frontend
    spec:
      containers:
      - name: frontend
        image: lego-loco-frontend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
        resources:
          limits:
            cpu: 200m
            memory: 256Mi
          requests:
            cpu: 50m
            memory: 128Mi
        startupProbe:
          httpGet:
            path: /health
            port: 3000
          failureThreshold: 18
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        env:
        - name: BACKEND_HOST
          value: "loco-loco-backend"
        - name: BACKEND_PORT
          value: "3001"
        - name: FRONTEND_PORT
          value: "3000"
        volumeMounts:
        - name: config
          mountPath: /usr/share/nginx/html/config
      volumes:
      - name: config
        configMap:
          name: loco-loco-instances
---
# Source: loco/templates/vr-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: loco-loco-vr
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: loco-loco-vr
      app.kubernetes.io/component: vr
      app.kubernetes.io/part-of: lego-loco-cluster
  template:
    metadata:
      labels:
        app: loco-loco-vr
        app.kubernetes.io/component: vr
        app.kubernetes.io/part-of: lego-loco-cluster
        app.kubernetes.io/name: lego-loco-vr
    spec:
      containers:
      - name: vr-frontend
        image: lego-loco-frontend:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 3000
        resources:
          limits:
            cpu: 200m
            memory: 256Mi
          requests:
            cpu: 50m
            memory: 128Mi
        env:
        - name: VITE_DEFAULT_VR
          value: "true"
        - name: BACKEND_HOST
          value: "loco-loco-backend"
        - name: BACKEND_PORT
          value: "3001"
        - name: FRONTEND_PORT
          value: "3000"
        volumeMounts:
        - name: config
          mountPath: /usr/share/nginx/html/config
      volumes:
      - name: config
        configMap:
          name: loco-loco-instances
---
# Source: loco/templates/emulator-statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: loco-loco-emulator
  namespace: default
spec:
  serviceName: loco-loco-emulator
  replicas: 1
  selector:
    matchLabels:
      app: loco-loco-emulator
      app.kubernetes.io/component: emulator
      app.kubernetes.io/part-of: lego-loco-cluster
  template:
    metadata:
      labels:
        app: loco-loco-emulator
        app.kubernetes.io/component: emulator
        app.kubernetes.io/part-of: lego-loco-cluster
        app.kubernetes.io/name: lego-loco-emulator
    spec:
      
      # Init containers for storage and disk image initialization
      initContainers:
      - name: init-hostpath-storage
        image: busybox:1.35
        command: ['sh', '-c']
        args:
        - |
          # Create shared directory with proper permissions
          mkdir -p /tmp/loco-art-shared
          chmod 777 /tmp/loco-art-shared
          
          # Create art subdirectory
          mkdir -p /tmp/loco-art-shared/art
          chmod 777 /tmp/loco-art-shared/art
          
          echo "HostPath storage initialized successfully"
          echo "Path: /tmp/loco-art-shared"
          ls -la /tmp/loco-art-shared
        volumeMounts:
          - name: hostpath-storage
            mountPath: /tmp/loco-art-shared
      
      # Init container for disk image population
      - name: init-disk-image
        image: qemu-loco:latest
        imagePullPolicy: Never
        command: ['sh', '-c']
        args:
        - |
          echo "Initializing disk image in PVC..."
          
          # Check if disk image already exists in PVC
          if [ -f /images/win98.qcow2 ]; then
            echo "‚úÖ Disk image already exists in PVC"
            ls -lh /images/win98.qcow2
            exit 0
          fi
          
          # Check if built-in disk image exists
          if [ -f /opt/builtin-images/win98.qcow2.builtin ]; then
            echo "üìã Copying built-in disk image to PVC..."
            cp /opt/builtin-images/win98.qcow2.builtin /images/win98.qcow2
            echo "‚úÖ Disk image copied to PVC successfully"
            ls -lh /images/win98.qcow2
          else
            echo "‚ùå Built-in disk image not found"
            echo "Available files in /opt/builtin-images:"
            ls -la /opt/builtin-images/
            exit 1
          fi
        volumeMounts:
          - name: disk
            mountPath: /images
            readOnly: false
      
      containers:
      - name: emulator
        image: qemu-loco:latest
        imagePullPolicy: Never
        env:
        - name: BRIDGE
          value: "loco-br"
        - name: DISK
          value: "/images/win98.qcow2"
        - name: DISPLAY_NUM
          value: "99"
        - name: TAP_IF
          value: "tap0"
        - name: USE_PREBUILT_SNAPSHOT
          value: "false"
        - name: ART_RES_ROOT
          value: "/nfs"
        - name: GIT_USER_NAME
          value: "Loco Watcher"
        - name: GIT_USER_EMAIL
          value: "watcher@example.com"
        securityContext:
          privileged: true
          capabilities:
            add:
              - NET_ADMIN
              - SYS_ADMIN
        ports:
        - containerPort: 5901
        - containerPort: 8080
          name: health
        startupProbe:
          httpGet:
            path: /
            port: 8080
          failureThreshold: 30
          periodSeconds: 10
          timeoutSeconds: 5
        livenessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 15
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        volumeMounts:
        - name: disk
          mountPath: /images
          readOnly: false
        - name: dev-net-tun
          mountPath: /dev/net/tun
        # Option 1: HostPath Direct Mounts
        - name: hostpath-storage
          mountPath: /nfs
        - name: emulator-scripts
          mountPath: /usr/local/bin/health-monitor.sh
          subPath: health-monitor.sh
        
        resources:
          limits:
            cpu: "1"
          requests:
            cpu: "0.25"

      volumes:
      - name: emulator-scripts
        configMap:
          name: loco-loco-emulator-scripts
          defaultMode: 0755
      - name: disk
        persistentVolumeClaim:
          claimName: win98-disk
      - name: dev-net-tun
        hostPath:
          path: /dev/net/tun
          type: CharDevice
      # Option 1: HostPath Direct Mounts
      - name: hostpath-storage
        hostPath:
          path: /tmp/loco-art-shared
          type: DirectoryOrCreate
